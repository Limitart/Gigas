package org.gigas.protoutil.compilerbat;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;

import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.input.SAXBuilder;

/**
 * 消息xml解析
 * 
 * @author hank
 * 
 */
public class ProtoXmlParser {
	private final static String packagePath = "option java_package = \"{@}\";\r\n";
	private final static String messageTypeName = "option java_outer_classname = \"{@}\";\r\n";
	private final static String optimize_for = "option optimize_for = LITE_RUNTIME;\r\n";
	private final static String messageHead = "message {@} {\r\n";
	private final static String messageBody = "\t{*} {@} {#}={$};";
	private final static String javasrcHead = "package {@}.message;\r\n";
	private final static String classname = "public class {@}MessageBuilder extends ProtoBufPackage {\r\n\r\n";
	private final static String field = "\tprivate {@} {#};// {$}\r\n\r\n";
	private final static String setMethod = "\tpublic void set{@}({#} {$}){ \r\n";
	private final static String setMethodBody = "\t\tthis.{@}={#};\r\n\t}\r\n";
	private final static String getMethod = "\tpublic {@} get{#}() {\r\n";
	private final static String getMethodBody = "\t\treturn this.{@};\r\n\t}\r\n";
	private final static String buildMethodHead = "\t@Override\r\n\tpublic {@}MessageFactory.{#} build() {\r\n";
	private final static String buildMethodBody = "\t\tBuilder builder = {@}MessageFactory.{#}.newBuilder();\r\n";
	private final static String javaHandlerHead = "package {@}.handler;\r\n";
	private final static String javaHandlerImport = "import {@}.message.proto.{#}MessageFactory.{$};\r\nimport org.gigas.core.server.handler.IHandler;\r\n\r\nimport com.google.protobuf.MessageLite;\r\n\r\n";
	private final static String javaHandlerClass = "public class {@}Handler extends IHandler {\r\n";

	public static void xmlParse(String path, boolean OverwriteHandler) throws JDOMException, IOException {
		File xmlfile = new File(path);
		if (!xmlfile.exists()) {
			System.err.println("文件" + path + "不存在");
			return;
		}
		File proto = new File(xmlfile.getParentFile().getParentFile().getParent() + "//proto");
		if (!proto.exists()) {
			proto.mkdir();
		}
		StringBuffer protosrcStringBuffer = new StringBuffer();
		protosrcStringBuffer.append("// Generated by the gigasGenerator.  DO NOT EDIT!\r\n\r\n");
		StringBuffer buildMethodBodyBuffer = new StringBuffer();
		SAXBuilder builder = new SAXBuilder();
		InputStream file = new FileInputStream(path);
		Document document = builder.build(file);// 获得对象
		Element root = document.getRootElement();// 获得根节点
		if (!"protos".equalsIgnoreCase(root.getName())) {
			System.err.println("错误的根节点名");
			return;
		}
		String packagename = root.getAttribute("package").getValue();
		String module = root.getAttribute("module").getValue();
		protosrcStringBuffer.append(packagePath.replace("{@}", packagename + ".message.proto"));
		protosrcStringBuffer.append(messageTypeName.replace("{@}", module + "MessageFactory"));
		protosrcStringBuffer.append(optimize_for);
		String baseId = root.getAttribute("id").getValue();
		List<Element> list = root.getChildren();
		for (Element temp : list) {
			if (!"message".equalsIgnoreCase(temp.getName())) {
				System.err.println("错误的子节点节点名");
				continue;
			}
			boolean needHandler = false;
			String type = temp.getAttribute("type").getValue();
			needHandler = "req".equalsIgnoreCase(type);
			String id = temp.getAttribute("id").getValue();// 消息id
			String name = temp.getAttribute("name").getValue();// 消息名称
			String annotation = temp.getAttribute("annotation").getValue();// 消息注释
			id = baseId + id;
			StringBuffer javasrcMessageStringBuffer = new StringBuffer();
			protosrcStringBuffer.append("//" + annotation + "\r\n");
			protosrcStringBuffer.append(messageHead.replace("{@}", name));
			javasrcMessageStringBuffer.append("// Generated by the gigasGenerator.  DO NOT EDIT!\r\n\r\n");
			javasrcMessageStringBuffer.append(javasrcHead.replace("{@}", packagename)).append("\r\n");
			// handler
			StringBuffer javasrcHandlerStringBuffer = new StringBuffer();
			if (needHandler) {
				javasrcHandlerStringBuffer.append("// Generated by the gigasGenerator.  ONLY CAN TODO 'handleMessage' Method!\r\n\r\n");
				javasrcHandlerStringBuffer.append(javaHandlerHead.replace("{@}", packagename)).append("\r\n");
				javasrcHandlerStringBuffer.append(javaHandlerImport.replace("{@}", packagename).replace("{#}", module).replace("{$}", name));
				javasrcHandlerStringBuffer.append(javaHandlerClass.replace("{@}", name)).append("\r\n");
				javasrcHandlerStringBuffer.append("\t@Override\r\n");
				javasrcHandlerStringBuffer.append("\tpublic void handleMessage(MessageLite message) {\r\n");
				javasrcHandlerStringBuffer.append("\t\t" + name + " msg = (" + name + ") message;\r\n");
				javasrcHandlerStringBuffer.append("\t\t// TODO\r\n");
				javasrcHandlerStringBuffer.append("\t}\r\n");
				javasrcHandlerStringBuffer.append("}");
			}
			List<Element> children = temp.getChildren();
			int count = 1;
			StringBuffer javaMethodStringBuffer = new StringBuffer();
			StringBuffer javaFieldStringBuffer = new StringBuffer();
			boolean needImportList = false;
			List<String> classTypeReferenceList = new ArrayList<String>();
			for (Element child : children) {
				boolean isList = false;
				String fieldtype = child.getAttribute("type").getValue();
				String fieldname = child.getAttribute("name").getValue();
				String fieldannotation = child.getAttribute("annotation").getValue();
				if (!isBaseType(fieldtype)) {
					classTypeReferenceList.add("import " + packagename + ".message.proto." + module + "MessageFactory." + fieldtype + ";" + "\r\n");
				}
				String optionOrRepeat = "optional";
				if ("list".equalsIgnoreCase(child.getName())) {
					optionOrRepeat = "repeated";
					isList = true;
					needImportList = true;
				}
				String typeStr = (isList ? "List<" + baseToClass(fieldtype) + ">" : fieldtype);
				protosrcStringBuffer.append(messageBody.replace("{@}", fieldtype(fieldtype)).replace("{#}", fieldname).replace("{$}", (count++) + "").replace("{*}", optionOrRepeat)).append("//").append(fieldannotation).append("\r\n");
				javaFieldStringBuffer.append(field.replace("{@}", typeStr).replace("{#}", fieldname).replace("{$}", fieldannotation));
				// setter
				javaMethodStringBuffer.append("\t/**\r\n");
				javaMethodStringBuffer.append("\t *" + fieldannotation + "setter\r\n");
				javaMethodStringBuffer.append("\t */\r\n");
				javaMethodStringBuffer.append(setMethod.replace("{@}", (fieldname.substring(0, 1).toUpperCase()) + fieldname.substring(1)).replace("{#}", typeStr).replace("{$}", fieldname));
				javaMethodStringBuffer.append(setMethodBody.replace("{@}", fieldname).replace("{#}", fieldname));
				// getter
				javaMethodStringBuffer.append("\r\n");
				javaMethodStringBuffer.append("\t/**\r\n");
				javaMethodStringBuffer.append("\t *" + fieldannotation + "getter\r\n");
				javaMethodStringBuffer.append("\t */\r\n");
				javaMethodStringBuffer.append(getMethod.replace("{@}", typeStr).replace("{#}", (fieldname.substring(0, 1).toUpperCase()) + fieldname.substring(1)));
				javaMethodStringBuffer.append(getMethodBody.replace("{@}", fieldname));
				// build
				String setStr = isList ? "addAll" : "set";
				buildMethodBodyBuffer.append("\t\tbuilder." + setStr + (fieldname.substring(0, 1).toUpperCase() + fieldname.substring(1)) + "(this." + fieldname + ");\r\n");
			}
			protosrcStringBuffer.append("}\r\n\r\n");
			if (needImportList) {
				javasrcMessageStringBuffer.append("import java.util.List;\r\n\r\n");
			}
			javasrcMessageStringBuffer.append("import " + packagename + ".message.proto." + module + "MessageFactory;\r\n");
			javasrcMessageStringBuffer.append("import " + packagename + ".message.proto." + module + "MessageFactory." + name + ".Builder;" + "\r\n");
			for (String tempStr : classTypeReferenceList) {
				javasrcMessageStringBuffer.append(tempStr);
			}
			javasrcMessageStringBuffer.append("import org.gigas.core.server.message.ProtoBufPackage;\r\n\r\n");
			javasrcMessageStringBuffer.append("import com.google.protobuf.MessageLite;\r\n\r\n\r\n");
			javasrcMessageStringBuffer.append(classname.replace("{@}", name));
			javaMethodStringBuffer.append("\r\n");
			javaMethodStringBuffer.append(buildMethodHead.replace("{@}", module).replace("{#}", name));
			javaMethodStringBuffer.append(buildMethodBody.replace("{@}", module).replace("{#}", name));
			javaMethodStringBuffer.append(buildMethodBodyBuffer);
			buildMethodBodyBuffer = new StringBuffer();
			javaMethodStringBuffer.append("\t\treturn builder.build();\r\n\t}\r\n\r\n");
			javaMethodStringBuffer.append("\t@Override\r\n");
			javaMethodStringBuffer.append("\tpublic int getId() {\r\n");
			javaMethodStringBuffer.append("\t\treturn " + id + ";\r\n");
			javaMethodStringBuffer.append("\t}\r\n\r\n");
			javaMethodStringBuffer.append("\t@Override\r\n");
			javaMethodStringBuffer.append("\tpublic Class<? extends MessageLite> getClazz() {\r\n");
			javaMethodStringBuffer.append("\t\t" + "return {@}MessageFactory.{#}.class;\r\n\t}\r\n".replace("{@}", module).replace("{#}", name));
			javaMethodStringBuffer.append("\t\r\n\r\n");
			javasrcMessageStringBuffer.append(javaFieldStringBuffer);
			javasrcMessageStringBuffer.append(javaMethodStringBuffer);
			javasrcMessageStringBuffer.append("}");
			System.out.println(javasrcMessageStringBuffer.toString());
			System.out.println(javasrcHandlerStringBuffer.toString());
			String replace = ProtoBufBatGenerator.getInstance().getOutputPath() + File.separator + packagename.replace(".", File.separator);
			File d1 = new File(replace);
			if (!d1.exists()) {
				d1.mkdir();
			}
			System.out.println(replace);
			replace += File.separator + "message";
			File d2 = new File(replace);
			if (!d2.exists()) {
				d2.mkdir();
			}
			System.out.println(replace);
			String javafile = name + "MessageBuilder.java";
			replace = replace + File.separator + javafile;
			System.out.println(replace);
			File jfile = new File(replace);
			FileOutputStream joutput = new FileOutputStream(jfile);
			joutput.write(javasrcMessageStringBuffer.toString().getBytes("UTF-8"));
			joutput.close();
			if (needHandler) {
				String handler = ProtoBufBatGenerator.getInstance().getOutputPath() + File.separator + packagename.replace(".", File.separator);
				File h1 = new File(handler);
				if (!h1.exists()) {
					h1.mkdir();
				}
				System.out.println(handler);
				handler += File.separator + "handler";
				File h2 = new File(handler);
				if (!h2.exists()) {
					h2.mkdir();
				}
				String javahanlderfile = name + "Handler.java";
				handler = handler + File.separator + javahanlderfile;
				System.out.println(handler);
				File jhfile = new File(handler);
				boolean canOverwrite = false;
				if (OverwriteHandler) {
					canOverwrite = true;
				} else if (!OverwriteHandler && jhfile.exists()) {
					canOverwrite = false;
				} else if (!OverwriteHandler && !jhfile.exists()) {
					canOverwrite = true;
				}
				if (canOverwrite) {
					FileOutputStream jhoutput = new FileOutputStream(jhfile);
					jhoutput.write(javasrcHandlerStringBuffer.toString().getBytes("UTF-8"));
					jhoutput.close();
				}
			}
		}
		System.out.println(protosrcStringBuffer.toString());
		File newprotofile = new File(xmlfile.getParentFile().getParentFile().getParent() + File.separator + "proto" + File.separator + module + ".proto");
		FileOutputStream out = new FileOutputStream(newprotofile);
		out.write(protosrcStringBuffer.toString().getBytes("UTF-8"));
		out.close();
	}

	private static String fieldtype(String s) {
		if ("string".equalsIgnoreCase(s)) {
			return "string";
		} else if ("int".equalsIgnoreCase(s)) {
			return "int32";
		} else if ("float".equalsIgnoreCase(s)) {
			return "float";
		} else if ("boolean".equalsIgnoreCase(s)) {
			return "bool";
		} else if ("long".equalsIgnoreCase(s)) {
			return "int64";
		} else if ("message".equalsIgnoreCase(s)) {
			return "message";
		} else if ("double".equalsIgnoreCase(s)) {
			return "double";
		}
		return s;
	}

	private static String baseToClass(String s) {
		if ("string".equalsIgnoreCase(s)) {
			return "String";
		} else if ("int".equalsIgnoreCase(s)) {
			return "Integer";
		} else if ("float".equalsIgnoreCase(s)) {
			return "Float";
		} else if ("boolean".equalsIgnoreCase(s)) {
			return "Boolean";
		} else if ("long".equalsIgnoreCase(s)) {
			return "Long";
		} else if ("double".equalsIgnoreCase(s)) {
			return "Double";
		}
		return s;
	}

	private static boolean isBaseType(String s) {
		if ("byte".equalsIgnoreCase(s))
			return true;
		else if ("short".equalsIgnoreCase(s))
			return true;
		else if ("int".equalsIgnoreCase(s))
			return true;
		else if ("long".equalsIgnoreCase(s))
			return true;
		else if ("float".equalsIgnoreCase(s))
			return true;
		else if ("double".equalsIgnoreCase(s))
			return true;
		else if ("char".equalsIgnoreCase(s))
			return true;
		else if ("boolean".equalsIgnoreCase(s))
			return true;
		else if ("String".equalsIgnoreCase(s))
			return true;
		return false;
	}
}
